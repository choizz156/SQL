# jpa

## 기존 jdbc 사용 문제

- sql을 수행하는 비용이 비쌈
- db마다 sql이 다름
- db 변경시 코드가 바뀜
- 반복적인 코드가 많음.

## jpa 사용 이유

- 도메인 기반의 프로그래밍으로 비지니스 로직을 구현하는데 집중 가능
    - 개발 생산성 좋음
- 데이터베이스에 종속되지 않아 데이터베이스에 독립적인 프로그래밍이 가능
    - 객체 지향 프로그래밍의 장점을 활용하기 좋음
- 캐시 기능으로 성능 최적화 가능
- 코드 재사용 가능
- 테스트 편함

## jpa 주의 사항

- 엔티티 매니져 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유.
- 엔티티 매니져는 스레드간 공유해선 안됨.
- jpa의 모든 데이터 변경은 트랜잭션 안에서 실행돼야 함.

## EntityManager

### 영속 컨텍스트

- 영속 객체를 관리할 때 `영속 컨텍스트`라는 집합을 사용함.
    - 메모리 저장소로, EntityManager가 관리할 엔티티 객체를 보관
    - 영속 컨텍스트에 보관한 엔티티를 구분할 때 식별자를 이용.
    - (엔티티 타입 + 식별자)를 키로 사용하고 엔티티를 값으로 사용하는 데이터 구조를 갖음.
    - <u>하이버네이트는 맵을 사용해서 영속 컨텍스트를 구현</u>
- db에서 읽어온 엔티티 객체를 영속 컨텍스트에 보관하고 save로 저장한 엔티티 객체 역시 영속 컨텍스트에 저장.
- 트랜잭션 커밋 시점에(명시적으로 flush할 경우) 영속 컨텍스트에 보관된 영속 객체의 변경 내영을 추적해서 db에 반영.

### 영속 컨텍스트와 캐시

- EntityManager 입장에서 영속 컨텍스트는 동일 식별자를 갖는 엔티티에 대한 캐시 역할을 함.
- EntityManager 객체를 종료하기 전까지만 유효한 캐시임.
- 서로 다른 EntityManager 객체에서 동일 식별자의 엔티티에 접근하면, 각 EntityManager select 쿼리를 실행하고 자신만의 영속 컨텍스트에 읽어온 엔티티 객체를 보관.

### 영속성 컨텍스트 이점

- `1차 캐시`
    - 1차 캐시에서 우선 검색하고 없으면 db 탐색
    - 성능 향상 가능
- `동일성 보장(==)`
    - 1차 캐시로 객체간 동일성이 보장됨
- `쓰기 지연(write behind)`
    - 커밋 되는 순간에 db에 쿼리를 한 번에 보냄.
    - 성능 향상 가능
- `변경 감지(dirty checking)`
    - 엔티티와 캐시 스냅샷을 비교하여 변경되는 것이 있을 경우, update sql 생성
    - update() 필요 x
- `지연 로딩(lazy loading)`
    - 프록시 객체를 가지고 있다가 조회 등으로 진짜 객체가 필요할 경우, 초기화 과정을 거쳐 db에서 조회 후 영속성 컨텍스트에 넣음.
    - 프록시 객체는 == 비교 시 실패함.

## 엔티티 생명 주기

- `비영속(new)` : 영속성 컨텍스트와 전혀 관계없는 새로운 객체 상태
- `영속(managed)` : 영속성 컨텍스트에 관리되는 상태
- `준영속(detached)` : 영속성 컨텍스트에 저장됐다가 분리된 상태
    - id를 기준으로 판별
    - 영속성 컨텍스트에 들어간 적이 없어도 임의로 id를 가지고 있으면 준영속상태이다.
- `삭제(removed)` : 삭제된 상태

### persist vs merge

#### persist

- 따로 조회하지 않아도 영속성 유지
- persist 시 id가 부여되지만 커밋되지 않으면 db에 반영되지 않음.
   ```
  item.getId() == null --> em.persist(item) --> item.getId() == 1이 적용됨.
   ```
- 새로운 엔티티가 영속성 컨텍스트에 저장됨.

#### merge(save and update)

- 준영속 상태의 엔티티를 영속 상태로 만들 때 쓰임.
- 비영속 상태도 쓰일 수 있음.

```
Item mergeItem = em.merge(item)
mergeItem != item
```

- mergeItem이라는 새로운 엔티티를 영속성 컨텍스트에 저장하고 업데이트하여 반환.
- mergeItem이 `영속 상태`로 있고 item은 `준영속 상태`에 머무름.

> merge는 엔티티의 전체 속성을 업데이트 한다. 만약 일부만 업데이트 하려다가 null이 입력될 수 있으니 주의해야 함.

## flush

- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 트랜잭션 커밋, jpql 쿼리 실행시 플러시를 자동 호출
    - jpql 쿼리 시행시 먼저 영속성 컨텍스트를 거치치 않음.
- em.flush() <- 직접 호출(쿼리를 미리 보고싶을 때 사용)

### 특징

- 영속성 컨텍스트를 비우지 않음.
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화.
- 트랜잭션이라는 작업 단위가 중요.
- 커밋이 돼야 적용.

### 플러시 실행 시

- 변경 감지가 동작, 스냅샷과 비교하여 수정된 엔티티를 찾음.
- 수정된 엔티티 쓰기 지연 sql 저장소에 등록.
- 쿼리를 전송