# jpa

## 기존 jdbc 사용 문제

- sql을 수행하는 비용이 비쌈
- db마다 sql이 다름
- db 변경시 코드가 바뀜
- 반복적인 코드가 많음.

## jpa 사용 이유

- 도메인 기반의 프로그래밍으로 비지니스 로직을 구현하는데 집중 가능
    - 개발 생산성 좋음
- 데이터베이스에 종속되지 않아 데이터베이스에 독립적인 프로그래밍이 가능
    - 객체 지향 프로그래밍의 장점을 활용하기 좋음
- 캐시 기능으로 성능 최적화 가능
- 코드 재사용 가능
- 테스트 편함

## jpa 주의 사항

- 엔티티 매니져 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유.
- 엔티티 매니져는 스레드간 공유해선 안됨.
- jpa의 모든 데이터 변경은 트랜잭션 안에서 실행돼야 함.

## EntityManager

### 영속 컨텍스트

- 영속 객체를 관리할 때 `영속 컨텍스트`라는 집합을 사용함.
    - 메모리 저장소로, EntityManager가 관리할 엔티티 객체를 보관
    - 영속 컨텍스트에 보관한 엔티티를 구분할 때 식별자를 이용.
    - (엔티티 타입 + 식별자)를 키로 사용하고 엔티티를 값으로 사용하는 데이터 구조를 갖음.
    - <u>하이버네이트는 맵을 사용해서 영속 컨텍스트를 구현</u>
- db에서 읽어온 엔티티 객체를 영속 컨텍스트에 보관하고 save로 저장한 엔티티 객체 역시 영속 컨텍스트에 저장.
- 트랜잭션 커밋 시점에(명시적으로 flush할 경우) 영속 컨텍스트에 보관된 영속 객체의 변경 내영을 추적해서 db에 반영.

### 영속 컨텍스트와 캐시

- EntityManager 입장에서 영속 컨텍스트는 동일 식별자를 갖는 엔티티에 대한 캐시 역할을 함.
- EntityManager 객체를 종료하기 전까지만 유효한 캐시임.
- 서로 다른 EntityManager 객체에서 동일 식별자의 엔티티에 접근하면, 각 EntityManager select 쿼리를 실행하고 자신만의 영속 컨텍스트에 읽어온 엔티티 객체를 보관.

## 엔티티 생명 주기

- `비영속(new)` : 영속성 컨텍스트와 전혀 관계없는 새로운 객체 상태
- `영속(managed)` : 영속성 컨텍스트에 관리되는 상태
- `준영속(detached)` : 영속성 컨텍스트에 저장됐다가 분리된 상태
    - id를 기준으로 판별
    - 영속성 컨텍스트에 들어간 적이 없어도 임의로 id를 가지고 있으면 준영속상태이다.
- `삭제(removed)` : 삭제된 상태
