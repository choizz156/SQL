# jpa

## 기존 jdbc 사용 문제

- sql을 수행하는 비용이 비쌈
- db마다 sql이 다름
- db 변경시 코드가 바뀜
- 반복적인 코드가 많음.

## jpa 사용 이유

- 도메인 기반의 프로그래밍으로 비지니스 로직을 구현하는데 집중 가능
    - 개발 생산성 좋음
- 데이터베이스에 종속되지 않아 데이터베이스에 독립적인 프로그래밍이 가능
    - 객체 지향 프로그래밍의 장점을 활용하기 좋음
- 캐시 기능으로 성능 최적화 가능
- 코드 재사용 가능
- 테스트 편함

## jpa 주의 사항

- 엔티티 매니져 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유.
- 엔티티 매니져는 스레드간 공유해선 안됨.
- jpa의 모든 데이터 변경은 트랜잭션 안에서 실행돼야 함.

## EntityManager

### 영속 컨텍스트

- 영속 객체를 관리할 때 `영속 컨텍스트`라는 집합을 사용함.
    - 메모리 저장소로, EntityManager가 관리할 엔티티 객체를 보관
    - 영속 컨텍스트에 보관한 엔티티를 구분할 때 식별자를 이용.
    - (엔티티 타입 + 식별자)를 키로 사용하고 엔티티를 값으로 사용하는 데이터 구조를 갖음.
    - <u>하이버네이트는 맵을 사용해서 영속 컨텍스트를 구현</u>
- db에서 읽어온 엔티티 객체를 영속 컨텍스트에 보관하고 save로 저장한 엔티티 객체 역시 영속 컨텍스트에 저장.
- 트랜잭션 커밋 시점에(명시적으로 flush할 경우) 영속 컨텍스트에 보관된 영속 객체의 변경 내영을 추적해서 db에 반영.

### 영속 컨텍스트와 캐시

- EntityManager 입장에서 영속 컨텍스트는 동일 식별자를 갖는 엔티티에 대한 캐시 역할을 함.
- EntityManager 객체를 종료하기 전까지만 유효한 캐시임.
- 서로 다른 EntityManager 객체에서 동일 식별자의 엔티티에 접근하면, 각 EntityManager select 쿼리를 실행하고 자신만의 영속 컨텍스트에 읽어온 엔티티 객체를 보관.

### 영속성 컨텍스트 이점

- `1차 캐시`
    - 1차 캐시에서 우선 검색하고 없으면 db 탐색
    - 성능 향상 가능
- `동일성 보장(==)`
    - 1차 캐시로 객체간 동일성이 보장됨
- `쓰기 지연(write behind)`
    - 커밋 되는 순간에 db에 쿼리를 한 번에 보냄.
    - 성능 향상 가능
- `변경 감지(dirty checking)`
    - 엔티티와 캐시 스냅샷을 비교하여 변경되는 것이 있을 경우, update sql 생성
    - update() 필요 x
- `지연 로딩(lazy loading)`
    - 프록시 객체를 가지고 있다가 조회 등으로 진짜 객체가 필요할 경우, 초기화 과정을 거쳐 db에서 조회 후 영속성 컨텍스트에 넣음.
    - 프록시 객체는 == 비교 시 실패함.

## 엔티티 생명 주기

- `비영속(new)` : 영속성 컨텍스트와 전혀 관계없는 새로운 객체 상태
- `영속(managed)` : 영속성 컨텍스트에 관리되는 상태
- `준영속(detached)` : 영속성 컨텍스트에 저장됐다가 분리된 상태
    - id를 기준으로 판별
    - 영속성 컨텍스트에 들어간 적이 없어도 임의로 id를 가지고 있으면 준영속상태이다.
- `삭제(removed)` : 삭제된 상태

### persist vs merge

#### persist

- 따로 조회하지 않아도 영속성 유지
- persist 시 id가 부여되지만 커밋되지 않으면 db에 반영되지 않음.
   ```
  item.getId() == null --> em.persist(item) --> item.getId() == 1이 적용됨.
   ```
- 새로운 엔티티가 영속성 컨텍스트에 저장됨.

#### merge(save and update)

- 준영속 상태의 엔티티를 영속 상태로 만들 때 쓰임.
- 비영속 상태도 쓰일 수 있음.

```
Item mergeItem = em.merge(item)
mergeItem != item
```

- mergeItem이라는 새로운 엔티티를 영속성 컨텍스트에 저장하고 업데이트하여 반환.
- mergeItem이 `영속 상태`로 있고 item은 `준영속 상태`에 머무름.

> merge는 엔티티의 전체 속성을 업데이트 한다. 만약 일부만 업데이트 하려다가 null이 입력될 수 있으니 주의해야 함.

## flush

- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 트랜잭션 커밋, jpql 쿼리 실행시 플러시를 자동 호출
    - jpql 쿼리 시행시 먼저 영속성 컨텍스트를 거치치 않음.
- em.flush() <- 직접 호출(쿼리를 미리 보고싶을 때 사용)

### 특징

- 영속성 컨텍스트를 비우지 않음.
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화.
- 트랜잭션이라는 작업 단위가 중요.
- 커밋이 돼야 적용.

### 플러시 실행 시

- 변경 감지가 동작, 스냅샷과 비교하여 수정된 엔티티를 찾음.
- 수정된 엔티티 쓰기 지연 sql 저장소에 등록.
- 쿼리를 전송

## 객체와 테이블 매핑

### @Entity

- jpa가 관리
- 테이블과 매핑할 클래스에 사용

#### 주의

- 기본생성자 필수(public, protected)
- final 클래스, enum, interface, inner 클래스 사용 안됨.
- 저장할 필드에 final 사용 안됨.

## 연관관계 매핑

- 객체를 테이블에 맞추어 데이터 중심으로 모델링 한다면, 협력 관계를 만들기 어려움.
- 객체의 참조와 테이블의 외래 키를 매핑
    - 참조 대신, 외래 키를 그대로 사용하면, 외래 키 식별자를 직접 다룸으로서, 연관 관계가 없고 객체 지향적인 방법이 아님.

### 단방향 연관관계

- 단방향으로만 연관 관계를 가짐.
    - user는 team을 참조하나, team은 user를 참조하지 않음.

```java
public class User {

	@Id
	private Long id;

	@Column(name = "user_name")
	private String name;

	@ManyToOne
	@JoinColumn(name = "team_id")
	private Team team;

}
```

### 양방향 연관 관계와 연관 관계 주인

- 양쪽 객체에 연관관계를 가짐.

```java
import java.util.ArrayList;

public class User {

	@Id
	private Long id;

	@Column(name = "user_name")
	private String name;

	@ManyToOne
	@JoinColumn(name = "team_id")
	private Team team;

}

public class Team {

	@Id
	private Long id;

	@OneToMany(mappedBy = team)
	List<User> users = new ArrayList<>();
}
```

### 연관관계 주인과 mapped by

#### 연관관계 주인

- 객체 두 관계 중 하나를 연관관계 주인으로 지정
- 주인 만이 외래키를 관리(등록, 수정)
- 주인 아닌 쪽은 읽기만 가능
- 주인은 mapped by 사용 x
- 주인이 아닌 경우 mapped by 사용

> 외래키가 있는 곳을 주인으로 정하자. (보통 일대다에서 '다')

### 양방향 매핑 시 연관관계의 주인에 값을 입력해야

- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정
- 연관관계 편의 메소드를 생성
- 양방향 매핑시 무한 루프 조심
    - toString(), lombok, json 라이브러리를 조심해야함.

### 정리

- 단방향 매핑만으로 이미 연관관계는 매핑된 상황
- 양방향 매핑은 객체 그래프 탐색 기능이 추가된 것임
- jpql에서 역방향으로 탐색할 일 많음
- 단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨
    - 테이블에 영향을 주지 않기 때문

## 다양한 연관관계 매핑

### 다대일 단방향

- 가장 많이 사용

### 다대일 양방향

- 외래 키가 있는 쪽이 연관관계 주인
- 양쪽을 서로 참조하도록 개발

### 일대다 단방향

- 권장하지 않음
- 1이 연관관계의 주인
- 그러나, 테이블은 항상 n쪽에 외래키가 있음 -> 외래키가 다른 테이블에 있음
- db에서는 연관관계 관리를 위해 update쿼리를 추가하여 fk를 만들어줘야함

### 일대일

- 주 테이블이나 대상 테이블 중에 외래키 선택 가능
- 외래키에 db 유니크 제약조건 추가

#### 주 테이블에 외래 키 단방향

- 다대일 단방향과 매우 유사

#### 주 테이블에 외래 키 양방향

- 다대일 양방향 매핑처럼 외래키가 있는 곳이 주인
- 반대편은 mapped by 적용

#### 정리

- 주 테이블에 외래키

    - 객체 지향 개발자 선호
    - 매핑 편리
    - 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
    - 값이 없으면, 외래키에 null 허용

- 대상 테이블에 외래키

    - db 개발자 선호
    - 일대일에서 일대다로 변경될때, 변경할 테이블 구조 유지
    - 프록시 기능 한계로 지연 로딩으로 설정해도 항상 즉시 로딩 됨.
        - 테이블을 확인해야 하기 때문에 지연로딩이 의미 없음.

### 다대다

- 연결테이블이 연결만하고 끝나는데 실무에선 다른 필드들이 들어갈 수 있음
- 연결 테이블용 엔티티 추가
- 일대다, 다대일로 변경
