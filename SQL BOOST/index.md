# index
- 테이블 내의 데이터를 찾을 수 있게 일부 데이터를 모아서 구성한 데이터 구조
- 인덱스를 이용하면 테이블 내의 데이터를 빠르게 찾아낼 수 있음.

##  최적의 인덱스를 만들려면..
- 인덱스의 물리적인 구조를 이해해야
- 복잡한 sql을 분해해서 이해할 수 있는 능력
- 만들어진 인덱스가 어떻게 사용될지 예측할 수 있는 능력
- 테이블 내의 데이터 속성을 파악할 수 있는 능력
- join의 내부적인 처리방법(nested, loops, merge, hash)의 이해

### 인덱스 전
- full scan으로 약 4초
![](image/no-index.png)

### 인덱스 후
- 0.1초로 단축
- buffers 258k -> 24로 단축
![](image/index.png)

## 인덱스 종류
### 단일 인덱스
- 인덱스에 하나의 컬럼만 사용
  - 고객id, 주문번호 등등 단일 컬럼일 경우
### 복합 인덱스
- 인덱스에 두 개 이상의 컬럼을 사용
- 복합 인덱스로 여러 sql을 커버하는 것이 좋음.
    - sql 별로 필요한 인덱스를 모두 만들다 보면 인덱스가 너무 많아짐.

### 유니크 인덱스
- 인덱스 구성 컬럼들 값에 중복을 허용하지 않음.
    - pk 제약 조건 등 업무적으로 유니크한 속성들을 파악해서 유니크 인덱스를 만들어 주는 것이 좋음
### 비유니크 인덱스
- 인덱스 구성 컬럼들 값에 중복을 허용함
  -
### b트리 인덱스
- 트리형 자료구조를 사용
### 비트맴 인덱스
- 값의 종류가 많지 않은 컬럼에서 사용
- 주문 유형의 값이 '주문대기', '주문완료' 두 가지만 있다면 고려 가능.
-  b트리 인덱스가 성능 면에서 유리할 때가 많음.
### IOT(Index Organized Table)
- 테이블 자체를 특정 컬럼 기준으로 인덱스화 하는 개념
- 클러스터드 인덱스와 같은 개념
  - mysql은 pk를 무조건 클러스터드 인덱스로 구성
  - 오라클은 잘 사용안함 
- b트리로 구성

### 파티션
- 대용량 테이블에는 파티션을 구성하는 것이 좋음
- 파티션 없이 인덱스를 만들어 사용하기에는 성능에 한계가 있음
- 오래된 데이터는 별도 저장소로 백업한 후 주기적으로 지우는 것이 비용과 성능에 도움이 된다.
이때, 파티션이 매우 유용
- 파티션 테이블에는 파티션 된 인덱스를 만들 수 있음
  - 글로벌 인덱스
  - 로컬 인덱스

> 분류를 혼합해서 인덱스를 생성 할 수 있다.
> - 복합 인덱스 면서 유니크인 b트리 인덱스
> - 단일 인ㄷ게스면서 비트맴 형태 인덱스 등등
