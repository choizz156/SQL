# 실행계획

- 작업 계획서
- sql 구문 분석 -> 실행계획 생성 -> 실행계획대로 실행
- 실행계획에 따라 성능이 달라지므로 sql 성능을 개성하려면 실행계획에 대한 이해가 필요하다

## 실행계획 확인

```sql
explain plan for ...

select * from table(dbms_xplan.display());
```

- **예상** 실행계획을 만들어 plan 테이블에 저장한다.
  ![](image/img.png)
- id 항목 : 식별자, 실행되는 순서 x
    - 1번이 0번의 자식
        - <mark>자식 단계가 먼저 실행됨.</mark>
- Predicate Information
    - 실행계획의 각 단계에서 사용한 조건이나 연산정보를 준다.
    - 해당 단계를 어떤 조건으로 처리했는지에 따라 성능 차이 발생

### 각 항목

- id: 실행계획의 오퍼레이션 id
- operation: 해당 단계에 수행한 작업 내용
- name : 작업을 수행한 대상 오브젝트(테이블 또는 인덱스)
- rows: 해당 단계 수행 시 조회될 예상 데이터 건수
- bytes: 해당 단계까지 사용될 예상 데이터양 (누적)
- cost: 해당 단계까지 사용될 예상 비용(누적)
- time: 해당 단계까지 사용될 예상 시간(누적)

## 실행계획의 순서

![](image/img_1.png)

- 자식이 부모보다 먼저 수행된다.
- 형제간에는 형(위에 있는 오퍼레이션)이 먼저 수행된다.
- 정확한 순서보다는 실행계획 트리를 통해 흐름을 파악하는 것이 중요.
    - 어느 오퍼레이션이 어느 오퍼레이션보다 먼저 수행되는지, 어떤 오퍼레이션이 수행되는지가 중요

## 실제 실행계획 확인하기

- /*+ gather_plan_statistics */ 힌트 추가

```sql
select
/*+ gather_plan_statistics */
    *
from ...


```
- 실제 실행계획을 만든 sql의 sql_id 찾기
```sql
select t1.sql_id, t1.child_number, t1.sql_text
from V$SQL t1
where t1.sql_text like '%gather_plan_statistics%'
order by t1.last_active_time desc;
```
- 실제 실행계획 조회하기(예상과 다를 수 있음)
```sql
select *
from table(dbms_xplan.display_cursor('<sqlId>',0,'ALLSTATS LAST'));
```
![](image/img_1.png)

- `A-Rows, A-Times, Buffers` 항목의 수치가 눈에 띄게 높아진 단계가 있다면 원인을 찾아 성능 개선하면 됨.
  - A-Rows : 해당 단계의 실제 데이터 건수
  - A-Times: 해당 단계까지 수행된 실제 시간(누적)
    - 복잡한 실행계획이나 병렬 쿼리에서 부정확하게 나오는 경우가 있음.
  - Buffers : 해당 단계까지 메모리 버퍼에서 읽은 블록수(논리적 io 횟수, 누적)

- 실제 운용에서는 gather_plan_statistics 이 힌트를 넣으면 불필요한 수치 수집으로 성능상의 손해를 볼 수 있음. 