# 문서번호 처리 기술
채번 -> id나 문서번호를 부여하는것을 의미
## selete max 방식
- 구매오더 테이블의 채번 규칙
  - PO(고정문자) + YYYYMMDD(요청일자) + NNNNNNNN(순번8자리)
### select ~ max 
```sql
DECLARE
    V_NEW_PO_NO VARCHAR2(40);
    V_REQ_DT    DATE;
    V_REQ_YMD   VARCHAR2(8);
BEGIN
    V_REQ_DT := TO_DATE('20250211 23:59:59', 'YYYYMMDD HH24::MI:SS');
    V_REQ_YMD := TO_CHAR(V_REQ_DT, 'YYYYMMDD');

    SELECT 'PO' || V_REQ_YMD ||
           LPAD(
                   TO_CHAR(
                           TO_NUMBER(
                                   NVL(SUBSTR(
                                               MAX(T1.PO_NO), -8), '0')
                           ) + 1
                   ), 8, '0'
           )
    INTO
        V_NEW_PO_NO
    FROM T_PO T1
    WHERE T1.REQ_DT >= TO_DATE(V_REQ_YMD, 'YYYYMMDD')
      AND T1.REQ_DT < TO_DATE(V_REQ_YMD, 'YYYYMMDD') + 1;

    INSERT INTO T_PO(PO_NO, TIT, REQ_DT, REQ_UID)
    VALUES (V_NEW_PO_NO, 'TEST_' || V_NEW_PO_NO, V_REQ_DT, 'TEST');
    COMMIT;
END;
```
- t_po에서 요청이랒에 해당하는 가장 큰 po_no를 가져와 새로운 po_no를 채번하고 있음
  - po_no는 문자열이므로 채번을 하려면 숫자부분만 잘라서 처리해야함.
- 채번된 값은 V_NEW_PO_NO에 저장하고 있다 신규데이터를 insert함

> - 이러한 select max 방식은 혼자 테스트했을 경우는 문제 없음.
> - 동시에 여러명이 사용할 때를 고려해야함.
>   - 잠재적인 오류가 있을 수 있음.

## select max 방식의 성능
### req_dt를 이용한 select max
- 채번을 위한 맨 마지막 po_no 조회
```sql
select /*+ gather_plan_statistics */
    max(t1.po_no)
from T_PO t1
where t1.REQ_DT >= to_date('20170302', 'YYYYMMDD')
  and t1.REQ_DT < to_date('20170302', 'YYYYMMDD') + 1;
```
- req_dt에 대한 인덱스가 없기 때문에 full scan이 발생함

```sql
create index x_t_po_1 on T_PO(REQ_DT, PO_NO);
```
- max 처리하는 po_no와 req_dt를 복합 인덱스로 만든다.
- buffers가 8912에서 56으로 개선
- 그런 A_Rows가 10,000건으로, max 값을 구하기 위해 인덱스 리프 블록에서 만 건의 데이터에 접근함.

### index range scan(min/max)
- select max의 성능이 최적화되려면 실행계획에 index range scan(min/max)가 나와야함.
  - ` index range scan(min/max)` : 인덱스를 이용해 최댓값이나 최솟값을 빠르게 구하는 오퍼레이션
- ` index range scan(min/max)`은 제일 뒤에 있는 max(po_no)나 제일 앞에 있는 min(po_no)를 한 건만 읽음.
  - 이미 인덱스로 정렬이 돼있음.
- index range scan만 쓴다면 조건에 해당하는 리프 데이터를 모두 읽어야함.
- <u>선두 컬럼이 '범위 조건'이면, `index range scan(min/max)`를 사용할 수 없음 </u>
- <mark>'=' 조건일 경우에만 index range scan(min/max)를 사용할 수 있음'</mark>
  - req_dt는 date 타입이기 때문에 시분초까지 포함하고 같다(=) 조건으로 특정 하루의 모든 데이터를 조회할 수 없음
```sql
ALTER TABLE T_PO ADD REQ_YMD VARCHAR2(8);

update T_PO set REQ_YMD = to_char(REQ_DT, 'YYYYMMDD');

create index x_t_po_2 on T_PO(REQ_YMD, PO_NO);
```
- 테이블에 req_ymd를 넣어서 req_dt를 문자열로 관리
- 인덱스도 새로 생성
- `index range scan(min/max)`가 사용되어 a_rows가 10,000에서 1로 개선, Buffers도 56 -> 2로 개선됨.
> - max/min 집계함수가 사용된 sql의 실행계획에는 ` index range scan(min/max)`가 나오는 것이 좋음
> - 성능은 개선했지만, req_dt와 중복 속성인 req_ymd 컬럼을 추가한 것에 대해서는 고민할 필요가 있음.
>   - 같은 값을 중복해서 관리하는 것은 의외로 많은 문제가 있음.