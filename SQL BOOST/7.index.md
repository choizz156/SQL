

# index

- `조건에 맞는` 테이블 내의 데이터를 찾을 수 있게 일부 데이터를 모아서 구성한 데이터 구조
- 인덱스를 이용하면 테이블 내의 데이터를 빠르게 찾아낼 수 있음.

## 최적의 인덱스를 만들려면..

- 인덱스의 물리적인 구조를 이해해야
- 복잡한 sql을 분해해서 이해할 수 있는 능력
- 만들어진 인덱스가 어떻게 사용될지 예측할 수 있는 능력
- 테이블 내의 데이터 속성을 파악할 수 있는 능력
- join의 내부적인 처리방법(nested, loops, merge, hash)의 이해

### 인덱스 전

- full scan으로 약 4초
  ![](image/no-index.png)

### 인덱스 후

- 0.1초로 단축
- buffers 258k -> 24로 단축
  ![](image/index.png)

## 인덱스 종류

### 단일 인덱스

- 인덱스에 하나의 컬럼만 사용
  - 고객id, 주문번호 등등 단일 컬럼일 경우

### 복합 인덱스

- 인덱스에 두 개 이상의 컬럼을 사용
- 복합 인덱스로 여러 sql을 커버하는 것이 좋음.
  - sql 별로 필요한 인덱스를 모두 만들다 보면 인덱스가 너무 많아짐.

### 유니크 인덱스

- 인덱스 구성 컬럼들 값에 중복을 허용하지 않음.
  - pk 제약 조건 등 업무적으로 유니크한 속성들을 파악해서 유니크 인덱스를 만들어 주는 것이 좋음

### 비유니크 인덱스

- 인덱스 구성 컬럼들 값에 중복을 허용함
  -------------------------------------

### b트리 인덱스

- 트리형 자료구조를 사용

### 비트맴 인덱스

- 값의 종류가 많지 않은 컬럼에서 사용
- 주문 유형의 값이 '주문대기', '주문완료' 두 가지만 있다면 고려 가능.
- b트리 인덱스가 성능 면에서 유리할 때가 많음.

### IOT(Index Organized Table)

- 테이블 자체를 특정 컬럼 기준으로 인덱스화 하는 개념
- 클러스터드 인덱스와 같은 개념
  - mysql은 pk를 무조건 클러스터드 인덱스로 구성
  - 오라클은 잘 사용안함
- b트리로 구성

### 파티션

- 대용량 테이블에는 파티션을 구성하는 것이 좋음
- 파티션 없이 인덱스를 만들어 사용하기에는 성능에 한계가 있음
- 오래된 데이터는 별도 저장소로 백업한 후 주기적으로 지우는 것이 비용과 성능에 도움이 된다.
  이때, 파티션이 매우 유용
- 파티션 테이블에는 파티션 된 인덱스를 만들 수 있음
  - 글로벌 인덱스
  - 로컬 인덱스

> 분류를 혼합해서 인덱스를 생성 할 수 있다.
>
> - 복합 인덱스 면서 유니크인 b트리 인덱스
> - 단일 인덱스면서 비트맵 형태 인덱스 등등

## B* 트리

- 균형이 잡혀 있고 근접한 리프 노드가 연결된 구조
- `B` : balanced 의미 -> 리프 노드들이 같은 수준에 자리해 있다는 의미
- `*` : 근접한 리프 노드가 연결된 구조를 의미

## 인덱스 블록

- 루트
  - 최상위에 단 하나만 존재
  - 하위 브랜치 블록의 인덱스 키 값과 주소를 가지고 있음.
- 브랜치
  - 루트와 리프의 중간 위치, 브랜치는 여러 층이 있을 수 있음.
- 리프
  - 최하위에만 위치
  - `인덱스 키 값(인덱스를 구성하는 컬럼)`과 데이터의 로우 위치(ROWID)를 가지고 있음.
  - 리프 블록은 인덱스 키 값 순으로 정렬
    ![](image/b트리.png)

### 루트 블록

![](image/루트블록.png)

- `20170104`를 찾아야함
- 세 개의 브랜치 블록(B05, B06, B01)을 찾아갈 수 있음.
- `20170104`는 빈값보다 크고 20170601보다 작음 -> B05로 이동

### 브랜치 블록

![](image/브랜치블록.png)

- 세 개의 리프블록을 가지고 있음
- `20170104`는 20170102보다 크고  20170104보다 작거나 같으므로 -> `B10으로` 이동
- B21로의 이동은 B10 뒷부분에도 `20170104`가 있을 수 있으므로 가서는 안됨.

### 리프 노드

![](image/리프노드.png)

- B10 마지막 부분에 `20170104`가 있음 <- B21로 이동했다면 rid_23에 있는 데이터는 찾지 못함
- 인덱스를 검색해서 리프 블록에 도달하면 리프 블록을 차례대로 스캔
  - 찾으려는 값보다 큰 값을 발견하기 전까지 수행
  - B10 첫 번째 데이터에서 시작해 B21 블록의 20170105를 만날 때 까지 스캔 진행
- ROWID를 참고해 실제 테이블 접근 작업을 수행

## 데이터를 찾는 방법

### 테이블 전체 읽기(table access full, 풀 스캔)

- 테이블의 데이터 블록을 차례대로 모두 읽으면서 필요한 데이터를 찾는 방법
- 인덱스가 없거나 인덱스보다 테이블 전체를 읽는 것이 효율적일 경우 사용
- 오라클에서 데이터가 테이블에 저장될 때는 특정 순서를 갖는다고 장담할 수 없음
- 데이터가 `백만 건` 정도 된다면 인덱스를 사용하는 것 보다 풀 스캔이 효율적일 수 있다.
  ![](image/데이터저장.png)

### 인덱스를 이용한 찾기(index range scan & table access by index rowid)

- 인덱스를 이용해 필요한 데이터만 찾는 방법
- 필요에 따라 table access by index rowid를 동반한다.

```
1. 루트에서 리프로 : 검색 조건에 해당하는 첫 번재 리프 블록을 찾는 과정
2. 리프 블록 스캔: 찾아낸 지점부터 리프 블록을 차례대로 읽어 가는 과정
=> `1 + 2 index range scan이라 함`
3. 테이블 접근: 리프 블록을 스캔하면서 필요에 따라 테이블에 접근하는 과정
=> `table access by index rowid라 함.`
```
#### (1) 루트에서 리프로
- 매우 빠르게 이루어짐
#### (2) 리프 블록 스탠(range scan)
- <mark>인덱스의 키 컬럼이 차례대로 정렬돼 있음</mark>
- 해당 데이터보다 큰 값을 만날때 까지 스캔
![](image/range-scan.png)

#### (3)테이블 접근(table access by index rowid)
- 리프 블록의 rouwid 값을 참조해 테이블의 데이터를 찾아가는 과정
- 테이블에서 필요한 값이 있을 때만 일어난다.
  - cus_id가 인덱스가 지정돼 있지 않다면 `table access by index rowid` 작업을 수행
```sql
create index x_t_ord_big_1 on t_ord_big(ord_ymd);
  
select /*+ gather_plan_statistics */
    t1.CUS_ID, count(*) ord_cnt
from t_ord_big t1
where t1.ORD_YMD = '20170316'
group by t1.CUS_ID
order by t1.CUS_ID;
```

## 인덱스 vs 풀스캔
### 랜덤 액세스(random access)
- io 작업 한 번에 하나의 블록을 가져오는 접근 방법
- 인덱스 리프 블록에서 rowid를 통해 테이블에 접근할 때 랜덤 액세스 발생
- 실행 계획에는 table access by index rowid로 표시
- 찾으려는 데이터가 많지 않으면 효율 좋음 그렇지 않으면 비효율

```sql
select /*+ gather_plan_statistics */
    t1.CUS_ID, count(*) ord_cnt
from t_ord_big t1
where t1.ORD_YMD = '20170316'
group by t1.CUS_ID
order by t1.CUS_ID;
```
- 위 sql은 총 3천만 건의 데이터 중, 5 만건의 데이터가 있음
  - 여기서 인덱스는 효율적임
  - 데이터 건 수가 아닌 `블록 수로 판단해야함.`
```sql
-- 약 7백만 건의 달하는 대량 데이터임.
-- 인덱스 사용
select /*+ gather_plan_statistics index(t1 x_t_ord_big_1) */
    t1.ord_st, sum(t1.ord_amt)
from t_ord_big t1
where t1.ORD_YMD between '20170401' and '20170630'
group by t1.ord_st;

select t1.SQL_ID, t1.CHILD_NUMBER, t1.SQL_TEXT
from V$SQL t1
where t1.SQL_TEXT like '%gather_plan_statistics%'
order by t1.LAST_ACTIVE_TIME;

```
![](image/인덱스2.png)
- table access by index rowid가 7,650k 번 실행 됨
  - 바로 전 단계인 index range scan의 a-rows 수 많큼 실행됨
=> 매우 많은 랜덤 액세스가 발생.

![](image/풀스캔2.png)
- 인덱스로 처리할 때보다 속도가 빨라짐
- Buffers 수치도 낮아짐
- <mark>찾고자 하는 데이터가 특정 수준 이상으로 많으면 인덱스를 이용한 랜덤 액세스보다 full scan 방식이 효율적</mark>
  - 하지만, 테이블에 데이터가 계속 쌓이는 구조라면 full scan 방식은 시간이 지날 수록 성능이 나빠진다.
  - 이런경우, 데이터를 잘라내거나 파티션 전략을 수립할 필요가 있다.

```
- 상대적으로 적은 양의 데이터를 읽는다면 인덱스가 유리하다.
- 많은 양의 데이터를 읽어야 한다면 full scan이 유리할 수 있다.
- full scan은 데이터가 쌓일수록 성능이 점차 나빠진다. 테이블 전략이 필요하다.
```

## 단일 인덱스

### 단일 인덱스 컬럼 정하기
- 조건에 맞는 데이터를 빠르게 찾기 위해 인덱스를 사용
- where 조건절에 사용된 커럼에 인덱스를 구성하는 것이 기본 원리

```sql
-- - 인덱스없이 5초 정도 소요됨.
select /*+ gather_plan_statistics */
  to_char(t1.ord_dt, 'YYYYMM'),
  count(*)
from T_ORD_BIG t1
where t1.CUS_ID = 'CUS_0064'
  and t1.PAY_TP = 'BANK'
  and t1.RNO = 2
group by to_char(t1.ord_dt, 'YYYYMM');
```
- 효율적인 단일 인덱스 찾기
  - 위의 sql에서 인덱스 후보들은 cus_id, pay_tp, rno 3개임
```sql
-- 컬럼 별 조건에 따른 결과 건수
select 'CUS_ID' col, count(*) cnt from T_ORD_BIG t1 where t1.CUS_ID  = 'CUS_0064'
union all
select 'PAY_TP' col, count(*) cnt from T_ORD_BIG t1 where t1.PAY_TP = 'BANK'
union all
select 'RNO' col, count(*) cnt from T_ORD_BIG t1 where t1.RNO = 2;

-- cus_id -> 340,000
-- pay_tp -> 9,150,000
-- rno -> 3,047
```
- 선택성이 좋은 컬럼을 사용하는 것이 좋음.
  - 조건에 해당하는 데이터가 `적을수록 선택성이 좋고`, 많을수록 안 좋음
- 따라서, 단일 인덱스를 생성해야 한다면, `rno를` 선택하는 것이 좋음.

#### 선택성이 좋은 컬럼
```sql
create index x_t_ord_big_2 on T_ORD_BIG(rno);


select /*+ gather_plan_statistics index(t1 x_t_ord_big_2)*/
    to_char(t1.ord_dt, 'YYYYMM'),
    count(*)
from T_ORD_BIG t1
where t1.CUS_ID = 'CUS_0064'
  and t1.PAY_TP = 'BANK'
  and t1.RNO = 2
group by to_char(t1.ord_dt, 'YYYYMM');


select t1.SQL_ID, t1.CHILD_NUMBER, t1.SQL_TEXT
from V$SQL t1
where t1.SQL_TEXT like '%gather_plan_statistics%'
order by t1.LAST_ACTIVE_TIME;

select *
from table (DBMS_XPLAN.DISPLAY_CURSOR('d69uxzw80puar', 0, 'ALLSTATS LAST'));
```
![](image/선택성이%20좋은%20컬럼.png)

- 인덱스를 이용해 3047건의 데이터를 찾고, 이 데이터를 랜덤 액세스함.

#### 선택성이 안 좋은 컬럼

```sql
create index x_t_ord_big_3 on T_ORD_BIG (CUS_ID);

select /*+ gather_plan_statistics index(t1 x_t_ord_big_2)*/
    to_char(t1.ord_dt, 'YYYYMM'),
    count(*)
from T_ORD_BIG t1
where t1.CUS_ID = 'CUS_0064'
  and t1.PAY_TP = 'BANK'
  and t1.RNO = 2
group by to_char(t1.ord_dt, 'YYYYMM');


select t1.SQL_ID, t1.CHILD_NUMBER, t1.SQL_TEXT
from V$SQL t1
where t1.SQL_TEXT like '%gather_plan_statistics%'
order by t1.LAST_ACTIVE_TIME;
```
![](image/선택성이%20안%20좋은%20컬럼.png)
- rno를 사용하는 것보다 오래 걸림.
  - index range scan 단계에서 340K의 A-ROW가 나오고 이 갯수를 모두 랜덤 액세스.
  - Buffers도 245k에 달함.

### 단일 인덱스 vs 복합 인덱스
- 복합 인덱스는 두 개 이상의 컬럼으로 구성된 인덱스
- 하나의 복합 인덱스로 여러 개의 인덱스를 대신 할 수 있는 장점이 있음.
  - 인덱스가 많아질수록 입력, 수정, 삭제에서는 성능 감소가 발생함.
  - 데이터 변경이 발생할 때 마다 인덱스 역시 변경을 해주어야 함.
- 따라서, 복합 인덱스로 인덱스 수를 줄이는 것은 중요함.

```sql
-- ord_ymd 인덱스 사용
select /*+ gather_plan_statistics index(t1 x_t_ord_big1) */
    t1.ord_st,
    count(*)
from T_ORD_BIG t1
where t1.ORD_YMD like '201703%'
and t1.CUS_ID = 'CUS_0075'
group by t1.ord_st;
```
![](image/복합인덱스사용전.png)
- 단일 인덱스를 사용할 경우 1,850k건의 orm_ymd 데이터와 cus_id 값을 찾기위해 테이블에 액세스해야 함.

```sql
-- 복합인덱스 적용(컬럼 순서는 신경쓰지 않음)
create index x_t_ord_big_3 on T_ORD_BIG(ORD_YMD, CUS_ID);

select /*+ gather_plan_statistics index(t1 x_t_ord_big3) */
  t1.ord_st,
  count(*)
from T_ORD_BIG t1
where t1.ORD_YMD like '201703%'
  and t1.CUS_ID = 'CUS_0075'
group by t1.ord_st;
```
![](image/복합인덱스사용.png)

- A-ROWS의 횟수가 3,000에 불과함.
  - 인덱스에 조건 컬럼의 정보가 모두 있음.
  - 테이블에 접근하지 않아도 조건에 맞는 데이터를 찾을 수 있음.
  - 다만, ord_st 컬럼은 인덱스에 없으므로 테이블 접근은 피할 수 없음.
- <mark>랜덤 액세스가 백만 번 이상 발생한다면 좋은 성능을 기대하기 어려움.</mark>

![](image/단일인덱스vs복합인덱스.png)
- 단일 인덱스는 ord_ymd조건은 인덱스를 통해 해결했지만, cus_id는 테이블에 접근해야함
- 복합 인덱스는 두 조건 모두 인덱스에서 해결 가능
  - ord_ymd별로 데이터가 정렬 -> cus_id 순으로 정렬

- 복합 인덱스를 너무 많이 사용하면 삽입,삭제,수정시 성능 저하가 나타난다.

