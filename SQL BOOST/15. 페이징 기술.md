# 페이징 기술
## 페이징 종류
### was 페이징
모든 데이터를 가져와 was에서 페이징 처리
- 사용하면 안됨
- 30건이 필요한데, 3만 데이터를 db에서 was로 전송하는 것은 네트워크 부하가 심하고, 페이징 처리하는 was 부하도 심함

### DB 페이징
- sql 성능까지 고려한 방법은 아님
- 조회에 필요한 데이터를 모두 읽은 다음 페이지에 필요한 칸믄만 데이터로 잘라서 was로 보냄
- was에 부하를 주지 않는 대신, db에서 모든 부하를 받음

### DB 인덱스 페이징(저자가 임의로 지은 이름)
- 인덱스를 이용해 필요한 데이터만 정확히 읽어내는 방법
- 인덱스와 rownum을 이용해 구현
- 성능이 가장 좋음
- 상황에 따라서 사용 불가능할 때도 있음

## DB 페이징
- 가장 흔함
- rownum을 이용해 페이징에 필요한 데이터만 골라냄
```sql
SELECT T1.ORD_SEQ,
       T1.ORD_YMD,
       T1.CUS_ID,
       T2.CUS_NM,
       T3.RGN_NM,
       T1.ORD_ST,
       T1.ITM_ID
FROM T_ORD_JOIN T1,
     M_CUS T2,
     M_RGN T3
WHERE T1.ORD_YMD LIKE '201703%'
  AND T1.CUS_ID = T2.CUS_ID
  AND T3.RGN_ID = T2.RGN_ID
ORDER BY T1.ORD_YMD DESC, T1.ORD_SEQ DESC;
```
- 192,000건이 조회 되는데 이렇게 많은 데이터를 한 번에 보여주기는 무리가 있음
- 데이터를 내려보내는 중에 was나 클라이언트 환경에 심한 부하가 발생할 것

### 첫 페이지 조회
```oracle
SELECT *
FROM (SELECT T1.ORD_SEQ,
             T1.ORD_YMD,
             T1.CUS_ID,
             T2.CUS_NM,
             T3.RGN_NM,
             T1.ORD_ST,
             T1.ITM_ID
      FROM T_ORD_JOIN T1,
           M_CUS T2,
           M_RGN T3
      WHERE T1.ORD_YMD LIKE '201703%'
        AND T1.CUS_ID = T2.CUS_ID
        AND T3.RGN_ID = T2.RGN_ID
      ORDER BY T1.ORD_YMD DESC, T1.ORD_SEQ DESC) T_PG1
WHERE ROWNUM <= 30;
```
- 원래의 sql을 인라인 뷰로 처리하고, 바깥에서 rownum을 사용해 30건만 조회
- <u>order by는 인라인 뷰 안쪽에, rownum은 인라인 뷰 바깥쪽에 위치해야 order by 순서에 맞는 데이터를 찾을 수 있음</u>

### 첫 페이지 조회 - rownum 잘못 사용
```oracle
SELECT T1.ORD_SEQ,
       T1.ORD_YMD,
       T1.CUS_ID,
       T2.CUS_NM,
       T3.RGN_NM,
       T1.ORD_ST,
       T1.ITM_ID
FROM T_ORD_JOIN T1,
     M_CUS T2,
     M_RGN T3
WHERE T1.ORD_YMD LIKE '201703%'
  AND T1.CUS_ID = T2.CUS_ID
  AND T3.RGN_ID = T2.RGN_ID
  AND ROWNUM <= 30 -- 여기
ORDER BY T1.ORD_YMD DESC, T1.ORD_SEQ DESC;
```
- rownum이 order by 이전에 처리되므로 정렬 순서가 뒤죽박죽이 됨.
```
- rownum을 인라인 뷰 바깥에서 사용하는 경우는 'sort order by stopkey'가 수행된 후 'count stopkey'가 수행됨 => 정상수행
- 인라인 뷰 안쪽에 수행하는 경우 count stopkey -> sort order by가 수행 => 데이터의 정확성이 떨어짐.
```
### 두 번째 페이지 처리 - rownum 잘못 사용
```oracle
SELECT *
FROM (SELECT T1.ORD_SEQ,
             T1.ORD_YMD,
             T1.CUS_ID,
             T2.CUS_NM,
             T3.RGN_NM,
             T1.ORD_ST,
             T1.ITM_ID
      FROM T_ORD_JOIN T1,
           M_CUS T2,
           M_RGN T3
      WHERE T1.ORD_YMD LIKE '201703%'
        AND T1.CUS_ID = T2.CUS_ID
        AND T3.RGN_ID = T2.RGN_ID
      ORDER BY T1.ORD_YMD DESC, T1.ORD_SEQ DESC) T_PG1
WHERE ROWNUM >= 31
  AND ROWNUM <= 60;
```
- ROWNUM은 조회되는 데이터에 1부터 차례대로 번호를 매김.
  - 1을 거치지 않고 2나 3이 나올 수 없음.

### 두 번째 페이지 처리 - 정상적인 방법
- 두 번째 페이지를 조회하려면 인라인 - 뷰를 한 번더 사용해야함.
```oracle
SELECT *
FROM (SELECT ROWNUM RNO, T1.*
      FROM (
               SELECT T1.ORD_SEQ,
                   T1.ORD_YMD,
                   T1.CUS_ID,
                   T2.CUS_NM,
                   T3.RGN_NM,
                   T1.ORD_ST,
                   T1.ITM_ID
            FROM T_ORD_JOIN T1,
                 M_CUS T2,
                 M_RGN T3
            WHERE T1.ORD_YMD LIKE '201703%'
              AND T1.CUS_ID = T2.CUS_ID
              AND T3.RGN_ID = T2.RGN_ID
            ORDER BY T1.ORD_YMD DESC, T1.ORD_SEQ DESC
           ) T1
      WHERE ROWNUM <= 60) T2
WHERE T2.RNO >= 31;
```
- ROW_NUMBER를 사용하는 경우도 있지만, 페이징 처리에서는 성능 문제로 ROWNUM을 사용하는 것이 좋음.

> db 페이징은 성능을 고려하지 않음. -> 최종 30건을 위해 19만개의 데이터를 뒤짐.