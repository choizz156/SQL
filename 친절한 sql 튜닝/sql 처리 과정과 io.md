# sql 처리 과정과 i/o
## 1.1 sql 파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
sql은 기본적으로 구조적, 집합적, 선언적 질의 언어.<br/>
원하는 결과집합을 구조적, 집합적으로 선언하지만 집합을 만드는 과정은 절차적
### 1.1.2 sql 최적화
dbms 내부에서 옵티마이저가 프로시저를 작성하고 컴파일해서 실행가능한 상태로 만드는 과정.
1. sql 파싱
- 사용자로 부터 sql을 전달받으면 파서가 파싱을 진행
  - 파싱 트리 생성 : sql 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
  - syntax 체크 : 문법적 오류가 없는지 확인
  - semantic 체크 : 의미상 오류가 없는지 확인
    - 존재하지 않는 테이블이나 컬럼을 사용했는지, 권한이 있는지 등
2. sql 최적화
- 옵티마이저가 미리 수닙한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 것을 선택
3. 로우 소스 생성
- 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드나 프로시저 형태로 포맷팅하는 단계
- 로우 소스 생성기(row-source generator)가 수행
### 1.1.3 sql 옵티마이저
사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 추천해주는 dbms 핵심 엔진<br/>
서버 프로스세가 가진 기능.
1. 사용자로 부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획들을 찾아냄
2. 데이터 딕셔너리(data dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 통해 각 실행계획의 예상비용 산정.
3. 최저 비용을 나타내는 실행계획 선택

### 1.1.4 실행계획과 비용
`실행계획(Execution Plan)`으로 sql 실행경로 미리보기 할 수 있음
- `비용(cost)`은 쿼리를 수행하는 동안 발생할 것으로 <u>예상하는</u> i/o 횟수 또는 예상 소요시간을 표현한 값.
  - 실제와 차이 날 수 있음.
### 1.1.5 옵티마이져 힌트
개발자가 직접 더 효율적인 액세스 경로를 찾아 낼 수 있음<br/>
이때, 옵티마이저 힌트를 통해 데이터 액세스 경로를 바꿀 수 있음.
```oraclesqlplus
select /*+ index(A pk)*/ --이렇게 사용
고객명, 주소
from 고객 A
where 고객id = '000001';
```
#### 주의 사항
힌트 안에 인자를 나열할 땐, ','를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안됨.
```oraclesqlplus
/*+ index(A A_pk) index(B, B_pk)*/
/*+ index(A A_pk), full(B)*/ -- 이건 안됨.
```
테이블을 지정할 때 스키마 명까지 명시하면 안됨
```oraclesqlplus
/*+ index(SCOOTT.A A_pk) */
```
from 절에 alias를 지정했다면 힌트에도 반드시 alias를 지정해야 함.
```oraclesqlplus
select /*+ full(emp)*/ -- 무시함.
from emp A;
```

> 힌트를 사용할 거라면 옵티마이저가 절대로 다른 방식을 선택하지 못하도록 빈틈없이 기술해야함.