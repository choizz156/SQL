# sql 처리 과정과 i/o
## 1.1 sql 파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
sql은 기본적으로 구조적, 집합적, 선언적 질의 언어.<br/>
원하는 결과집합을 구조적, 집합적으로 선언하지만 집합을 만드는 과정은 절차적
### 1.1.2 sql 최적화
dbms 내부에서 옵티마이저가 프로시저를 작성하고 컴파일해서 실행가능한 상태로 만드는 과정.
1. sql 파싱
- 사용자로 부터 sql을 전달받으면 파서가 파싱을 진행
  - 파싱 트리 생성 : sql 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
  - syntax 체크 : 문법적 오류가 없는지 확인
  - semantic 체크 : 의미상 오류가 없는지 확인
    - 존재하지 않는 테이블이나 컬럼을 사용했는지, 권한이 있는지 등
2. sql 최적화
- 옵티마이저가 미리 수닙한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 것을 선택
3. 로우 소스 생성
- 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드나 프로시저 형태로 포맷팅하는 단계
- 로우 소스 생성기(row-source generator)가 수행
### 1.1.3 sql 옵티마이저
사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 추천해주는 dbms 핵심 엔진<br/>
서버 프로스세가 가진 기능.
1. 사용자로 부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획들을 찾아냄
2. 데이터 딕셔너리(data dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 통해 각 실행계획의 예상비용 산정.
3. 최저 비용을 나타내는 실행계획 선택

### 1.1.4 실행계획과 비용
`실행계획(Execution Plan)`으로 sql 실행경로 미리보기 할 수 있음
- `비용(cost)`은 쿼리를 수행하는 동안 발생할 것으로 <u>예상하는</u> i/o 횟수 또는 예상 소요시간을 표현한 값.
  - 실제와 차이 날 수 있음.
### 1.1.5 옵티마이져 힌트
개발자가 직접 더 효율적인 액세스 경로를 찾아 낼 수 있음<br/>
이때, 옵티마이저 힌트를 통해 데이터 액세스 경로를 바꿀 수 있음.
```oraclesqlplus
select /*+ index(A pk)*/ --이렇게 사용
고객명, 주소
from 고객 A
where 고객id = '000001';
```
#### 주의 사항
힌트 안에 인자를 나열할 땐, ','를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안됨.
```oraclesqlplus
/*+ index(A A_pk) index(B, B_pk)*/
/*+ index(A A_pk), full(B)*/ -- 이건 안됨.
```
테이블을 지정할 때 스키마 명까지 명시하면 안됨
```oraclesqlplus
/*+ index(SCOOTT.A A_pk) */
```
from 절에 alias를 지정했다면 힌트에도 반드시 alias를 지정해야 함.
```oraclesqlplus
select /*+ full(emp)*/ -- 무시함.
from emp A;
```

> 힌트를 사용할 거라면 옵티마이저가 절대로 다른 방식을 선택하지 못하도록 빈틈없이 기술해야함.

## sql 공유 및 재사용
### 1.2.1 소프트 파싱 vs 하드 파싱
- 라이브러리 캐시(library cache) : sql 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간
- SGA(system global area) : 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간
![](sga.png)
- `소프트 파싱` : sql을 캐시에허 찾아 곧바로 실행 단계로 넘어가는 것을 말함.
- `하드 파싱` : 캐시에서 찾는데 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것

#### sql 최적화 과정이 hard한 이유
- 옵티마이저가 sql을 최적화 할 때, 많은 일을 수행
  - 테이블 컬럼, 인덱스 구조에 관한 기본 정보
  - 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
  - 시스템 통계 : cpu 속도, 싱글 블록 io 속도, 멀티 블록 io 속도
  - 옵티마이저 관련 파라미터
- 하드 파싱은 cpu를 많이 소비하는 몇 안되는 작업 중 하나.
- 그래서 라이브러리 캐시가 필요함.

### 1.2.2 바인드 변수의 중요성
#### 이름 없는 sql 문제
- sql은 이름이 따로 없고 전체 sql 텍스트가 이름 역할을 함
- 딕셔너리에 저장하지도 않음
- 라이브러리 캐시에 적재함으로 써, 여러 사용자가 공유
- 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 적재
=> sql 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 탄생하는 구조
#### 공유 가능 sql
의미적으로는 같지만, 실행할 때 각각의 최적화를 진행하고 라이브러리 캐시에 별도 공간 사용
```oraclesqlplus
select * from emp where empno = 7900;
SELECT * FROM EMP WHERE EMPNO = 7900;
SELECT * FROM EMP WHERE EMPNO = 7900 ;
SELECT * FROM EMP WHERE EMPNO = 7900    ;

```
```java
"select * from customer where login_id = """+login_id+""";
```
- 이 sql은 모든 sql을 하드파싱하고 캐시에 적재하기 때문에 io 대비 cpu 사용량을 증가 시킴.

##### 바인드 변수 사용
```java
import java.sql.PreparedStatement;

String sql = "select * from customer where login_id = ?";
PreparedStatement st = con.preparedStatement(sql);
con.setString(1,login_id);

```
- 이 경우에 하드 파싱은 최초로 한 번만 일어나고, 재사용됨.
